{"openapi":"3.0.0","info":{"title":"Hasher-Matcher-Actioner (HMA) API","description":"OpenAPI specification for Meta's Hasher-Matcher-Actioner (HMA) system from ThreatExchange.\nHMA is a content moderation platform that provides content hashing, similarity matching, and curation capabilities for trust & safety applications.\n## Base URL Prefixes - `/h/*` - Hashing endpoints (ROLE_HASHER required) - `/m/*` - Matching endpoints (ROLE_MATCHER required)   - `/c/*` - Curation endpoints (ROLE_CURATOR required) - `/dev/*` - Development endpoints (non-production only) - `/ui/*` - User interface endpoints (UI_ENABLED required)\n","version":"1.0.0","contact":{"name":"ThreatExchange","url":"https://github.com/facebook/ThreatExchange","email":"threatexchange@meta.com"},"license":{"name":"BSD License","url":"https://github.com/facebook/ThreatExchange/blob/main/LICENSE"}},"servers":[{"url":"http://localhost:5000","description":"Local development server"},{"url":"https://your-hma-instance.com","description":"Production server"}],"paths":{"/":{"get":{"summary":"Home redirect","description":"Redirects to UI if enabled, otherwise to status endpoint","responses":{"302":{"description":"Redirect to appropriate endpoint"}}}},"/status":{"get":{"summary":"Health check","description":"Liveness/readiness check endpoint for load balancers","responses":{"200":{"description":"Service is healthy","content":{"text/plain":{"schema":{"type":"string","example":"I-AM-ALIVE"}}}},"503":{"description":"Service unavailable (e.g., index is stale)","content":{"text/plain":{"schema":{"type":"string","example":"INDEX-STALE"}}}}}}},"/site-map":{"get":{"summary":"Site map","description":"Returns list of all available routes","responses":{"200":{"description":"List of available routes","content":{"application/json":{"schema":{"type":"array","items":{"type":"string"},"example":["/status","/h/hash","/m/lookup"]}}}}}}},"/h/hash":{"get":{"tags":["Hashing"],"summary":"Hash content from URL","description":"Fetch content from a URL and return its hash signatures.\n\n**\u26a0\ufe0f Dynamic Response Structure**: Returns object with unpredictable keys (algorithm names).\n**TypeScript Challenge**: Requires `Record<string, string>` - cannot use strict interfaces.\n**Go Challenge**: Use `map[string]string` or `interface{}` for unknown keys.\n**Swift Challenge**: Use `[String: String]` dictionary type.\n\n**Memory Allocation Note**: Strongly-typed languages cannot pre-allocate memory for unknown object shapes.\nRuntime parsing and dynamic allocation required.\n\n**API Chaining Limitation**: Output cannot be directly piped to matching endpoints.\nManual transformation layer required.\n","parameters":[{"name":"url","in":"query","required":true,"schema":{"type":"string","format":"uri"},"description":"URL to the media content to hash"},{"name":"content_type","in":"query","required":false,"schema":{"type":"string","enum":["photo","video"]},"description":"Content type override if auto-detection fails"},{"name":"types","in":"query","required":false,"schema":{"type":"string"},"description":"Comma-separated list of signal types to compute"}],"responses":{"200":{"description":"Hash values computed successfully. \n\n**Response Structure**: Dynamic object with algorithm names as keys.\n**Available Algorithms**: Depends on content type and HMA configuration.\n**TypeScript Type**: `Record<string, string>`\n**Go Type**: `map[string]string`\n**Swift Type**: `[String: String]`\n","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HashResponse"},"examples":{"photo_hashes":{"summary":"Photo hashing response","description":"Typical response for image content","value":{"pdq":"facd8bcb2a49bcebdec1985298d5fe84bcd006c187c598c720c3c087b3fdb318","md5":"d41d8cd98f00b204e9800998ecf8427e","phash":"a1b2c3d4e5f6789a"}},"video_hashes":{"summary":"Video hashing response","description":"Typical response for video content","value":{"tmk":"1234567890abcdef1234567890abcdef","video_md5":"098f6bcd4621d373cade4e832627b4f6","frame_md5":"e99a18c428cb38d5f260853678922e03"}},"minimal_response":{"summary":"Single algorithm response","description":"When only one algorithm is available/enabled","value":{"pdq":"facd8bcb2a49bcebdec1985298d5fe84bcd006c187c598c720c3c087b3fdb318"}}}}}},"400":{"$ref":"#/components/responses/BadRequest"},"500":{"$ref":"#/components/responses/InternalServerError"}}},"post":{"tags":["Hashing"],"summary":"Hash uploaded content","description":"Calculate hash signatures for uploaded file content.\n\n**\u26a0\ufe0f Dynamic Response Structure**: Same dynamic object limitations as GET endpoint.\n**Strongly-Typed Languages**: Cannot predict response shape at compile time.\n**Manual Transformation Required**: For use with matching endpoints.\n","requestBody":{"required":true,"content":{"multipart/form-data":{"schema":{"type":"object","properties":{"photo":{"type":"string","format":"binary","description":"Photo file to hash"},"video":{"type":"string","format":"binary","description":"Video file to hash"}},"oneOf":[{"required":["photo"]},{"required":["video"]}]}}}},"responses":{"200":{"description":"Hash values computed successfully with dynamic algorithm keys.\nSee GET /h/hash for response structure details.\n","content":{"application/json":{"schema":{"$ref":"#/components/schemas/HashResponse"}}}},"400":{"$ref":"#/components/responses/BadRequest"}}}},"/m/raw_lookup":{"get":{"tags":["Matching"],"summary":"Raw hash lookup","description":"Look up a hash in the similarity index without enable/disable checks.\n\n**\u26a0\ufe0f Manual Input Required**: Cannot directly use hashing API output.\n**Transformation Needed**: Extract `signal` and `signal_type` from HashResponse.\n**Workflow**: Hash \u2192 Extract \u2192 Match (no direct chaining supported).\n","parameters":[{"name":"signal","in":"query","required":true,"schema":{"type":"string"},"description":"The hash/signal value to look up.\n**Source**: Must be extracted from HashResponse object.\n**Example**: `hashResponse[\"pdq\"]` or `hashResponse[\"md5\"]`\n"},{"name":"signal_type","in":"query","required":true,"schema":{"type":"string"},"description":"The signal type (algorithm name).\n**Source**: Must be a key from HashResponse object.\n**Example**: \"pdq\", \"md5\", \"sha256\", etc.\n**Available Values**: Depends on content type and HMA configuration.\n"},{"name":"include_distance","in":"query","required":false,"schema":{"type":"boolean","default":false},"description":"Whether to include distance values in matches"}],"responses":{"200":{"description":"Lookup results","content":{"application/json":{"schema":{"type":"object","properties":{"matches":{"oneOf":[{"type":"array","items":{"type":"integer"},"description":"Content IDs when include_distance=false"},{"type":"array","items":{"$ref":"#/components/schemas/MatchWithDistance"},"description":"Matches with distance when include_distance=true"}]}}}}}},"400":{"$ref":"#/components/responses/BadRequest"},"503":{"description":"Index not ready"}}}},"/m/lookup":{"get":{"tags":["Matching"],"summary":"Content lookup with URL","description":"Hash content from URL and find matches in banks.\n\n**Convenience Endpoint**: Combines hashing + matching in single call.\n**Note**: Still returns dynamic structure in results organized by signal type.\n","parameters":[{"name":"url","in":"query","required":true,"schema":{"type":"string","format":"uri"},"description":"URL to the content to match"},{"name":"banks","in":"query","required":false,"schema":{"type":"string"},"description":"Comma-separated list of bank names to search in"}],"responses":{"200":{"description":"Match results organized by bank and signal type.\n**Structure**: Dynamic nested objects requiring Record types.\n","content":{"application/json":{"schema":{"$ref":"#/components/schemas/MatchResultsByBank"}}}},"400":{"$ref":"#/components/responses/BadRequest"},"403":{"$ref":"#/components/responses/Forbidden"}}},"post":{"tags":["Matching"],"summary":"Content lookup with file upload","description":"Hash uploaded content and find matches in banks.\n\n**Convenience Endpoint**: Combines hashing + matching in single call.\n**Dynamic Results**: Returns nested dynamic objects by bank and signal type.\n","requestBody":{"required":true,"content":{"multipart/form-data":{"schema":{"type":"object","properties":{"photo":{"type":"string","format":"binary"},"video":{"type":"string","format":"binary"}},"oneOf":[{"required":["photo"]},{"required":["video"]}]}}}},"responses":{"200":{"description":"Match results organized by bank and signal type.\n**TypeScript**: `Record<string, Record<string, MatchWithDistance[]>>`\n","content":{"application/json":{"schema":{"$ref":"#/components/schemas/MatchResultsByBank"}}}},"400":{"$ref":"#/components/responses/BadRequest"},"403":{"$ref":"#/components/responses/Forbidden"}}}},"/m/index/status":{"get":{"tags":["Matching"],"summary":"Index status","description":"Get status of signal type indices","responses":{"200":{"description":"Index status information","content":{"application/json":{"schema":{"$ref":"#/components/schemas/IndexStatus"}}}}}}},"/m/compare":{"post":{"tags":["Matching"],"summary":"Compare hash signatures","description":"Compare two hash signatures for similarity","requestBody":{"required":true,"content":{"application/json":{"schema":{"type":"object","additionalProperties":{"type":"array","items":{"type":"string"},"minItems":2,"maxItems":2},"example":{"pdq":["facd8bcb2a49bcebdec1985298d5fe84bcd006c187c598c720c3c087b3fdb318","facd8bcb2a49bcebdec1985228d5ae84bcd006c187c598c720c2b087b3fdb318"]}}}}},"responses":{"200":{"description":"Comparison results","content":{"application/json":{"schema":{"type":"object","additionalProperties":{"type":"array","items":{"oneOf":[{"type":"boolean"},{"type":"object","properties":{"distance":{"type":"integer"}}}]}},"example":{"pdq":[true,{"distance":9}]}}}}},"400":{"$ref":"#/components/responses/BadRequest"}}}},"/c/banks":{"get":{"tags":["Curation"],"summary":"List banks","description":"Get list of all content banks","responses":{"200":{"description":"List of banks","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/BankConfig"}}}}}}},"post":{"tags":["Curation"],"summary":"Create bank","description":"Create a new content bank","requestBody":{"required":true,"content":{"application/json":{"schema":{"type":"object","required":["name"],"properties":{"name":{"type":"string","description":"Bank name"},"enabled":{"type":"boolean","description":"Whether bank is enabled (deprecated, use enabled_ratio)"},"enabled_ratio":{"type":"number","minimum":0.0,"maximum":1.0,"description":"Ratio of bank contents to consider for matching"}}}}}},"responses":{"201":{"description":"Bank created successfully","content":{"application/json":{"schema":{"$ref":"#/components/schemas/BankConfig"}}}},"400":{"$ref":"#/components/responses/BadRequest"},"403":{"description":"Bank already exists"}}}},"/c/bank/{bank_name}":{"get":{"tags":["Curation"],"summary":"Get bank details","description":"Get details of a specific bank","parameters":[{"$ref":"#/components/parameters/BankName"}],"responses":{"200":{"description":"Bank details","content":{"application/json":{"schema":{"$ref":"#/components/schemas/BankConfig"}}}},"404":{"description":"Bank not found"}}},"put":{"tags":["Curation"],"summary":"Update bank","description":"Update bank configuration","parameters":[{"$ref":"#/components/parameters/BankName"}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"type":"object","properties":{"name":{"type":"string","description":"New bank name"},"enabled":{"type":"boolean","description":"Whether bank is enabled"},"enabled_ratio":{"type":"number","minimum":0.0,"maximum":1.0,"description":"Ratio of bank contents to consider for matching"}}}}}},"responses":{"200":{"description":"Bank updated successfully","content":{"application/json":{"schema":{"$ref":"#/components/schemas/BankConfig"}}}},"400":{"$ref":"#/components/responses/BadRequest"},"403":{"description":"Bank name already exists"},"404":{"description":"Bank not found"}}},"delete":{"tags":["Curation"],"summary":"Delete bank","description":"Delete a content bank","parameters":[{"$ref":"#/components/parameters/BankName"}],"responses":{"200":{"description":"Bank deleted successfully","content":{"application/json":{"schema":{"type":"object","properties":{"message":{"type":"string","example":"Done"}}}}}}}}},"/c/bank/{bank_name}/content":{"post":{"tags":["Curation"],"summary":"Add content to bank","description":"Add content to a bank via URL or file upload","parameters":[{"$ref":"#/components/parameters/BankName"},{"name":"url","in":"query","required":false,"schema":{"type":"string","format":"uri"},"description":"URL to content to add to bank"},{"name":"metadata","in":"query","required":false,"schema":{"type":"string"},"description":"JSON metadata for the content"}],"requestBody":{"required":false,"content":{"multipart/form-data":{"schema":{"type":"object","properties":{"photo":{"type":"string","format":"binary"},"video":{"type":"string","format":"binary"},"metadata":{"type":"object","$ref":"#/components/schemas/BankedContentMetadata"}}}}}},"responses":{"200":{"description":"Content added successfully","content":{"application/json":{"schema":{"type":"object","properties":{"id":{"type":"integer","description":"Content ID"},"signals":{"type":"object","additionalProperties":{"type":"string"},"description":"Computed hash signatures"}}}}}},"400":{"$ref":"#/components/responses/BadRequest"},"404":{"description":"Bank not found"}}}},"/c/bank/{bank_name}/content/{content_id}":{"get":{"tags":["Curation"],"summary":"Get bank content","description":"Get details of specific content in a bank","parameters":[{"$ref":"#/components/parameters/BankName"},{"$ref":"#/components/parameters/ContentId"}],"responses":{"200":{"description":"Content details","content":{"application/json":{"schema":{"$ref":"#/components/schemas/BankContentConfig"}}}},"404":{"description":"Bank or content not found"}}},"put":{"tags":["Curation"],"summary":"Update bank content","description":"Update metadata for bank content","parameters":[{"$ref":"#/components/parameters/BankName"},{"$ref":"#/components/parameters/ContentId"}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"type":"object","properties":{"disable_until_ts":{"type":"integer","description":"Timestamp until which content is disabled"},"original_media_uri":{"type":"string","format":"uri","description":"Original media URI"}}}}}},"responses":{"200":{"description":"Content updated successfully","content":{"application/json":{"schema":{"$ref":"#/components/schemas/BankContentConfig"}}}},"400":{"$ref":"#/components/responses/BadRequest"},"404":{"description":"Bank or content not found"}}},"delete":{"tags":["Curation"],"summary":"Delete bank content","description":"Remove content from a bank","parameters":[{"$ref":"#/components/parameters/BankName"},{"$ref":"#/components/parameters/ContentId"}],"responses":{"200":{"description":"Content deleted successfully","content":{"application/json":{"schema":{"type":"object","properties":{"message":{"type":"string","example":"Done"}}}}}}}}},"/c/bank/{bank_name}/signal":{"post":{"tags":["Curation"],"summary":"Add signals to bank","description":"Add hash signatures directly to a bank","parameters":[{"$ref":"#/components/parameters/BankName"}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"type":"object","additionalProperties":{"type":"string"},"description":"Mapping of signal type to signal value","example":{"pdq":"facd8bcb2a49bcebdec1985298d5fe84bcd006c187c598c720c3c087b3fdb318","md5":"d41d8cd98f00b204e9800998ecf8427e"}}}}},"responses":{"200":{"description":"Signals added successfully","content":{"application/json":{"schema":{"type":"object","properties":{"id":{"type":"integer"},"signals":{"type":"object","additionalProperties":{"type":"string"}}}}}}}}}},"/c/exchanges/apis":{"get":{"tags":["Exchange APIs"],"summary":"List exchange APIs","description":"Get list of available signal exchange APIs","responses":{"200":{"description":"List of exchange API names","content":{"application/json":{"schema":{"type":"array","items":{"type":"string"},"example":["fb_threatexchange","static_sample"]}}}}}}},"/c/exchanges/api/{api_name}":{"get":{"tags":["Exchange APIs"],"summary":"Get exchange API config","description":"Get configuration for a specific exchange API","parameters":[{"$ref":"#/components/parameters/ApiName"}],"responses":{"200":{"description":"Exchange API configuration","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ExchangeAPIConfig"}}}}}},"post":{"tags":["Exchange APIs"],"summary":"Update exchange API config","description":"Update configuration for a specific exchange API","parameters":[{"$ref":"#/components/parameters/ApiName"}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"type":"object","properties":{"credential_json":{"type":"object","description":"API credentials (format depends on API type)"}}}}}},"responses":{"200":{"description":"Configuration updated successfully","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ExchangeAPIConfig"}}}}}}},"/c/exchanges":{"get":{"tags":["Exchanges"],"summary":"List exchanges","description":"Get list of configured signal exchanges/collaborations","responses":{"200":{"description":"List of exchanges","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/CollaborationConfig"}}}}}}},"post":{"tags":["Exchanges"],"summary":"Create exchange","description":"Create a new signal exchange/collaboration","requestBody":{"required":true,"content":{"application/json":{"schema":{"type":"object","required":["api","bank","api_json"],"properties":{"api":{"type":"string","description":"Exchange API type"},"bank":{"type":"string","description":"Associated bank name"},"api_json":{"type":"object","description":"API-specific configuration"}}}}}},"responses":{"201":{"description":"Exchange created successfully","content":{"application/json":{"schema":{"$ref":"#/components/schemas/CollaborationConfig"}}}},"400":{"$ref":"#/components/responses/BadRequest"}}}},"/c/exchange/{exchange_name}":{"get":{"tags":["Exchanges"],"summary":"Get exchange details","description":"Get details of a specific exchange","parameters":[{"$ref":"#/components/parameters/ExchangeName"}],"responses":{"200":{"description":"Exchange details","content":{"application/json":{"schema":{"$ref":"#/components/schemas/CollaborationConfig"}}}},"404":{"description":"Exchange not found"}}},"put":{"tags":["Exchanges"],"summary":"Update exchange","description":"Update exchange configuration","parameters":[{"$ref":"#/components/parameters/ExchangeName"}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"type":"object","properties":{"bank":{"type":"string","description":"Associated bank name"},"api_json":{"type":"object","description":"API-specific configuration"}}}}}},"responses":{"200":{"description":"Exchange updated successfully","content":{"application/json":{"schema":{"$ref":"#/components/schemas/CollaborationConfig"}}}},"400":{"$ref":"#/components/responses/BadRequest"},"404":{"description":"Exchange not found"}}},"delete":{"tags":["Exchanges"],"summary":"Delete exchange","description":"Delete a signal exchange","parameters":[{"$ref":"#/components/parameters/ExchangeName"}],"responses":{"200":{"description":"Exchange deleted successfully","content":{"application/json":{"schema":{"type":"object","properties":{"message":{"type":"string","example":"Exchange deleted"}}}}}}}}},"/c/exchange/{exchange_name}/status":{"get":{"tags":["Exchanges"],"summary":"Get exchange fetch status","description":"Get the fetch status for a signal exchange","parameters":[{"$ref":"#/components/parameters/ExchangeName"}],"responses":{"200":{"description":"Exchange fetch status","content":{"application/json":{"schema":{"$ref":"#/components/schemas/FetchStatus"}}}}}}},"/c/signal_type":{"get":{"tags":["Configuration"],"summary":"List signal types","description":"Get list of all signal types and their configurations","responses":{"200":{"description":"Signal type configurations","content":{"application/json":{"schema":{"type":"object","additionalProperties":{"$ref":"#/components/schemas/SignalTypeConfig"}}}}}}}},"/c/signal_type/{signal_type_name}":{"put":{"tags":["Configuration"],"summary":"Update signal type config","description":"Update configuration for a signal type","parameters":[{"name":"signal_type_name","in":"path","required":true,"schema":{"type":"string"},"description":"Signal type name (e.g., 'pdq', 'md5')"}],"requestBody":{"required":true,"content":{"application/json":{"schema":{"type":"object","properties":{"enabled":{"type":"boolean","description":"Whether signal type is enabled"}}}}}},"responses":{"200":{"description":"Signal type updated successfully","content":{"application/json":{"schema":{"$ref":"#/components/schemas/SignalTypeConfig"}}}}}}},"/c/signal_type/index":{"get":{"tags":["Configuration"],"summary":"Signal type index status","description":"Get indexing status for all signal types","responses":{"200":{"description":"Signal type index status","content":{"application/json":{"schema":{"type":"object","additionalProperties":{"$ref":"#/components/schemas/SignalTypeIndexStatus"}}}}}}}},"/c/content_type":{"get":{"tags":["Configuration"],"summary":"List content types","description":"Get list of all content types and their configurations","responses":{"200":{"description":"Content type configurations","content":{"application/json":{"schema":{"type":"object","additionalProperties":{"$ref":"#/components/schemas/ContentTypeConfig"}}}}}}}},"/dev/setup_sample_example":{"post":{"tags":["Development"],"summary":"Setup sample data","description":"Seed the system with sample data for testing","responses":{"302":{"description":"Redirect to UI home"}}}},"/dev/setup_tx_example":{"post":{"tags":["Development"],"summary":"Setup ThreatExchange example","description":"Create example ThreatExchange collaboration","responses":{"302":{"description":"Redirect to UI home"}}}},"/dev/seed_banks":{"post":{"tags":["Development"],"summary":"Seed random banks","description":"Create random banks for testing","responses":{"302":{"description":"Redirect to UI home"}}}},"/dev/factory_reset":{"post":{"tags":["Development"],"summary":"Factory reset","description":"Reset all database tables (destructive operation)","responses":{"302":{"description":"Redirect to UI home"}}}}},"components":{"parameters":{"BankName":{"name":"bank_name","in":"path","required":true,"schema":{"type":"string"},"description":"Name of the bank"},"ContentId":{"name":"content_id","in":"path","required":true,"schema":{"type":"integer"},"description":"Content ID"},"ApiName":{"name":"api_name","in":"path","required":true,"schema":{"type":"string"},"description":"Exchange API name"},"ExchangeName":{"name":"exchange_name","in":"path","required":true,"schema":{"type":"string"},"description":"Exchange name"}},"schemas":{"HashResponse":{"type":"object","additionalProperties":{"type":"string"},"description":"Dynamic object with algorithm names as keys and hash values as strings.\n\n**\u26a0\ufe0f CRITICAL LIMITATION FOR STRONGLY-TYPED LANGUAGES**:\n\nKeys are not predictable at compile-time and depend on:\n- Content type (photo/video) \n- Enabled signal types in HMA configuration\n- Available hashing algorithms\n- Runtime detection capabilities\n\n**Memory Allocation Impact**: Strongly-typed languages cannot pre-allocate \nstruct/object memory for unknown fields. Runtime allocation required.\n\n**JSON Parsing Challenges**: Standard JSON-to-struct mapping fails due to \nunknown field names. Dynamic parsing mechanisms required.\n","example":{"pdq":"facd8bcb2a49bcebdec1985298d5fe84bcd006c187c598c720c3c087b3fdb318","md5":"d41d8cd98f00b204e9800998ecf8427e","sha256":"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855","video_md5":"098f6bcd4621d373cade4e832627b4f6"},"x-strongly-typed-languages":"**TypeScript**: Record<string, string>\n**Go**: map[string]string or interface{}\n**Swift**: [String: String] or [String: Any]\n**Rust**: HashMap<String, String> or serde_json::Value\n**Java**: Map<String, String> or JsonObject\n**C#**: Dictionary<string, string> or JObject\n","x-language-usage":"// TypeScript - runtime parsing required due to dynamic keys\nconst hashResponse: Record<string, string> = await hashAPI();\nconst algorithms = Object.keys(hashResponse);\n\n// Go - use map or interface{} for unknown keys  \nvar hashResponse map[string]string\njson.Unmarshal(data, &hashResponse)\n// OR for safety:\nvar hashResponse interface{}\njson.Unmarshal(data, &hashResponse)\n\n// Swift - dictionary with string keys\nlet hashResponse: [String: String] = try JSONDecoder().decode([String: String].self, from: data)\nlet algorithms = Array(hashResponse.keys)\n\n// Rust - HashMap for dynamic keys\nuse std::collections::HashMap;\nlet hash_response: HashMap<String, String> = serde_json::from_str(&response)?;\n\n// Java - Map interface for dynamic structure\nMap<String, String> hashResponse = objectMapper.readValue(json, \n    new TypeReference<Map<String, String>>() {});\n\n// C# - Dictionary for unknown keys\nvar hashResponse = JsonSerializer.Deserialize<Dictionary<string, string>>(json);\n","x-memory-allocation-notes":"**Compile-Time Limitations**:\n- Cannot determine struct size at compile time\n- Field names unknown until runtime  \n- Memory layout unpredictable\n\n**Runtime Requirements**:\n- Dynamic memory allocation during JSON parsing\n- Hash map / dictionary data structures required\n- Cannot use fixed-size structs or stack allocation\n\n**Performance Impact**:\n- Heap allocation overhead vs stack allocation  \n- Hash map lookup costs vs direct field access\n- Runtime type checking in some languages\n","x-typescript-usage":"// Runtime parsing required due to dynamic keys\nconst hashResponse: Record<string, string> = await hashContent(file);\n\n// Cannot use strict Zod validation - keys unknown at compile time\nconst hashResponseSchema = z.record(z.string());\n\n// Manual extraction needed for matching API\nconst availableAlgorithms = Object.keys(hashResponse);\nconst firstAlgorithm = availableAlgorithms[0];\nconst matchingInput = {\n  signal: hashResponse[firstAlgorithm],\n  signal_type: firstAlgorithm\n};\n","x-workflow-limitation":"**API Chaining Limitation**: Direct chaining from hashing to matching is not supported.\nManual transformation is required to extract signal and signal_type from the dynamic response.\n\n**Transformation Required**:\n1. Parse dynamic HashResponse \n2. Iterate/select algorithm from keys\n3. Extract corresponding hash value\n4. Construct MatchingRequest object\n5. Submit to matching endpoint\n","x-workaround-examples":"**Complete Multi-Language Transformation Examples**:\n\n```typescript\n// TypeScript: Hash \u2192 Transform \u2192 Match\nasync function hashAndMatch(file: File, preferredAlgorithm?: string) {\n  // 1. Hash content (returns dynamic object)\n  const hashResponse: Record<string, string> = await hashContent(file);\n  \n  // 2. Transform for matching (manual extraction)\n  const algorithms = Object.keys(hashResponse);\n  const algorithm = preferredAlgorithm && algorithms.includes(preferredAlgorithm) \n    ? preferredAlgorithm \n    : algorithms[0];\n    \n  const matchingRequest = {\n    signal: hashResponse[algorithm],\n    signal_type: algorithm\n  };\n  \n  // 3. Find matches\n  return await findMatches(matchingRequest);\n}\n```\n\n```go\n// Go: Hash \u2192 Transform \u2192 Match\nfunc hashAndMatch(file []byte, preferredAlgorithm string) (interface{}, error) {\n  // 1. Hash content (returns dynamic map)\n  var hashResponse map[string]string\n  if err := json.Unmarshal(hashData, &hashResponse); err != nil {\n    return nil, err\n  }\n  \n  // 2. Transform for matching (manual extraction)\n  var algorithm string\n  if _, exists := hashResponse[preferredAlgorithm]; exists {\n    algorithm = preferredAlgorithm\n  } else {\n    // Pick first available\n    for k := range hashResponse {\n      algorithm = k\n      break\n    }\n  }\n  \n  matchingRequest := map[string]string{\n    \"signal\":      hashResponse[algorithm],\n    \"signal_type\": algorithm,\n  }\n  \n  // 3. Find matches\n  return findMatches(matchingRequest)\n}\n```\n\n```swift\n// Swift: Hash \u2192 Transform \u2192 Match\nfunc hashAndMatch(data: Data, preferredAlgorithm: String? = nil) async throws -> Any {\n  // 1. Hash content (returns dynamic dictionary)\n  let hashResponse: [String: String] = try JSONDecoder().decode([String: String].self, from: hashData)\n  \n  // 2. Transform for matching (manual extraction)\n  let algorithms = Array(hashResponse.keys)\n  let algorithm = preferredAlgorithm.flatMap { algorithms.contains($0) ? $0 : nil } ?? algorithms.first!\n  \n  let matchingRequest = [\n    \"signal\": hashResponse[algorithm]!,\n    \"signal_type\": algorithm\n  ]\n  \n  // 3. Find matches  \n  return try await findMatches(matchingRequest)\n}\n```\n"},"MatchingRequest":{"type":"object","required":["signal","signal_type"],"properties":{"signal":{"type":"string","description":"Hash value extracted from HashResponse.\n**Source**: Must be manually extracted from hashing API response.\n","example":"facd8bcb2a49bcebdec1985298d5fe84bcd006c187c598c720c3c087b3fdb318"},"signal_type":{"type":"string","description":"Algorithm name (key from HashResponse).\n**Source**: Must match a key from the hashing API response.\n\n**Common Values**: pdq, md5, sha1, sha256, sha512, video_md5, phash, dhash, ahash\n**Note**: Available types depend on content type and HMA configuration.\n","enum":["pdq","md5","sha1","sha256","sha512","video_md5","phash","dhash","ahash","tmk"],"example":"pdq"}},"example":{"signal":"facd8bcb2a49bcebdec1985298d5fe84bcd006c187c598c720c3c087b3fdb318","signal_type":"pdq"},"x-transformation-example":"// Step 1: Get hashing response\nconst hashResponse = await hashContent(file);\n// Result: { \"pdq\": \"...\", \"md5\": \"...\" }\n\n// Step 2: Manual transformation for matching\nconst algorithm = \"pdq\"; // or Object.keys(hashResponse)[0]\nconst matchingRequest: MatchingRequest = {\n  signal: hashResponse[algorithm],\n  signal_type: algorithm\n};\n\n// Step 3: Use in matching API\nconst matches = await findMatches(matchingRequest);\n"},"TypeScriptWorkflowExample":{"type":"object","description":"**Complete TypeScript Workflow Example**\n\nDemonstrates the manual transformation required between hashing and matching APIs\ndue to the dynamic response structure.\n","x-typescript-example":"// 1. Define types for dynamic responses\ntype HashResponse = Record<string, string>;\ntype MatchingRequest = { signal: string; signal_type: string };\n\n// 2. Hash content (returns dynamic object)\nasync function hashContent(file: File): Promise<HashResponse> {\n  const formData = new FormData();\n  formData.append('photo', file);\n  \n  const response = await fetch('/h/hash', {\n    method: 'POST',\n    body: formData\n  });\n  \n  return response.json(); // { \"pdq\": \"...\", \"md5\": \"...\" }\n}\n\n// 3. Transform for matching (manual extraction required)\nfunction prepareMatchingRequest(\n  hashResponse: HashResponse, \n  preferredAlgorithm?: string\n): MatchingRequest {\n  const algorithms = Object.keys(hashResponse);\n  const algorithm = preferredAlgorithm && algorithms.includes(preferredAlgorithm) \n    ? preferredAlgorithm \n    : algorithms[0];\n    \n  if (!algorithm) {\n    throw new Error('No algorithms available in hash response');\n  }\n  \n  return {\n    signal: hashResponse[algorithm],\n    signal_type: algorithm\n  };\n}\n\n// 4. Find matches\nasync function findMatches(request: MatchingRequest) {\n  const params = new URLSearchParams({\n    signal: request.signal,\n    signal_type: request.signal_type\n  });\n  \n  const response = await fetch(`/m/raw_lookup?${params}`);\n  return response.json();\n}\n\n// 5. Complete workflow\nasync function hashAndMatch(file: File, algorithm?: string) {\n  try {\n    // Hash the content\n    const hashResponse = await hashContent(file);\n    console.log('Available algorithms:', Object.keys(hashResponse));\n    \n    // Transform for matching\n    const matchingRequest = prepareMatchingRequest(hashResponse, algorithm);\n    console.log('Using algorithm:', matchingRequest.signal_type);\n    \n    // Find matches\n    const matches = await findMatches(matchingRequest);\n    return { hashResponse, matches };\n  } catch (error) {\n    console.error('Workflow failed:', error);\n    throw error;\n  }\n}\n","x-zod-limitations":"// Zod validation limitations due to dynamic keys\n\n// \u274c Cannot do this (keys unknown at compile time):\nconst StrictHashResponseSchema = z.object({\n  pdq: z.string(),\n  md5: z.string()\n});\n\n// \u2705 Must use this instead:\nconst DynamicHashResponseSchema = z.record(z.string());\n\n// \u2705 Validation at runtime:\nfunction validateHashResponse(data: unknown): HashResponse {\n  const schema = z.record(z.string().min(1));\n  return schema.parse(data);\n}\n\n// \u2705 Type-safe extraction:\nfunction extractSignal(\n  hashResponse: HashResponse, \n  algorithm: string\n): { signal: string; signal_type: string } | null {\n  if (!(algorithm in hashResponse)) {\n    return null;\n  }\n  \n  return {\n    signal: hashResponse[algorithm],\n    signal_type: algorithm\n  };\n}\n"},"MatchWithDistance":{"type":"object","required":["bank_content_id","distance"],"properties":{"bank_content_id":{"type":"integer","description":"ID of matching content in bank"},"distance":{"type":"string","description":"Distance/similarity score"}}},"MatchResultsByBank":{"type":"object","additionalProperties":{"type":"object","additionalProperties":{"type":"array","items":{"$ref":"#/components/schemas/MatchWithDistance"}}},"description":"Match results organized by bank and signal type.\n\n**Structure**: `Record<BankName, Record<SignalType, MatchWithDistance[]>>`\n**TypeScript Note**: Also requires Record types due to dynamic bank names and signal types.\n","example":{"EXAMPLE_BANK":{"pdq":[{"bank_content_id":123,"distance":"0"},{"bank_content_id":456,"distance":"5"}],"md5":[{"bank_content_id":789,"distance":"0"}]}},"x-typescript-type":"Record<string, Record<string, MatchWithDistance[]>>"},"IndexStatus":{"type":"object","additionalProperties":{"type":"object","properties":{"cache_type":{"type":"string","enum":["in_memory","build_on_query"]},"is_stale":{"type":"boolean"},"last_updated":{"type":"integer","description":"Unix timestamp"},"items_count":{"type":"integer"}}}},"BankConfig":{"type":"object","required":["name","matching_enabled_ratio"],"properties":{"name":{"type":"string","description":"Bank name"},"matching_enabled_ratio":{"type":"number","minimum":0.0,"maximum":1.0,"description":"Ratio of bank contents to consider for matching"},"enabled":{"type":"boolean","description":"Whether bank is enabled (derived from matching_enabled_ratio > 0)"}}},"BankedContentMetadata":{"type":"object","properties":{"content_id":{"type":"string","description":"User-defined content identifier"},"content_uri":{"type":"string","format":"uri","description":"URI to the original content"},"json":{"type":"object","additionalProperties":true,"description":"Additional metadata as JSON object"}}},"BankContentConfig":{"type":"object","required":["id","disable_until_ts","bank"],"properties":{"id":{"type":"integer","description":"Unique content ID"},"disable_until_ts":{"type":"integer","description":"Timestamp until which content is disabled (0=disabled, 1=enabled)"},"collab_metadata":{"type":"object","additionalProperties":{"type":"array","items":{"type":"string"}},"description":"Collaboration metadata"},"original_media_uri":{"type":"string","format":"uri","description":"URI to original media"},"bank":{"$ref":"#/components/schemas/BankConfig"},"enabled":{"type":"boolean","description":"Whether content is currently enabled"}}},"ExchangeAPIConfig":{"type":"object","required":["supports_authentification","has_set_authentification"],"properties":{"supports_authentification":{"type":"boolean","description":"Whether this API supports authentication"},"has_set_authentification":{"type":"boolean","description":"Whether authentication has been configured"}}},"CollaborationConfig":{"type":"object","required":["name","api","bank"],"properties":{"name":{"type":"string","description":"Exchange/collaboration name"},"api":{"type":"string","description":"Exchange API type"},"bank":{"type":"string","description":"Associated bank name"},"api_json":{"type":"object","description":"API-specific configuration"},"enabled":{"type":"boolean","description":"Whether exchange is enabled"}}},"FetchStatus":{"type":"object","properties":{"checkpoint_ts":{"type":"integer","nullable":true,"description":"Last checkpoint timestamp"},"running_fetch_start_ts":{"type":"integer","nullable":true,"description":"Current fetch start timestamp"},"last_fetch_complete_ts":{"type":"integer","nullable":true,"description":"Last fetch completion timestamp"},"last_fetch_succeeded":{"type":"boolean","nullable":true,"description":"Whether last fetch succeeded"},"up_to_date":{"type":"boolean","description":"Whether exchange is up to date"},"fetched_items":{"type":"integer","description":"Number of items fetched"},"fetch_in_progress":{"type":"boolean","description":"Whether fetch is currently in progress"}}},"SignalTypeConfig":{"type":"object","required":["signal_type","enabled"],"properties":{"signal_type":{"type":"string","description":"Signal type class name"},"enabled":{"type":"boolean","description":"Whether signal type is enabled"}}},"SignalTypeIndexStatus":{"type":"object","properties":{"type":{"type":"string","description":"Signal type name"},"enabled":{"type":"boolean","description":"Whether signal type is enabled"},"checkpoint":{"type":"object","properties":{"last_item_timestamp":{"type":"integer"},"last_item_id":{"type":"integer"},"total_hash_count":{"type":"integer"}}}}},"ContentTypeConfig":{"type":"object","required":["content_type","enabled"],"properties":{"content_type":{"type":"string","description":"Content type class name"},"enabled":{"type":"boolean","description":"Whether content type is enabled"}}},"ErrorResponse":{"type":"object","required":["message"],"properties":{"message":{"type":"string","description":"Error message"}}}},"responses":{"BadRequest":{"description":"Bad request","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorResponse"},"example":{"message":"url is required"}}}},"Forbidden":{"description":"Forbidden - required role not enabled","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorResponse"},"example":{"message":"ROLE_HASHER is not enabled"}}}},"InternalServerError":{"description":"Internal server error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ErrorResponse"},"example":{"message":"Internal server error"}}}}}},"tags":[{"name":"Hashing","description":"Content hashing operations"},{"name":"Matching","description":"Content matching and lookup operations"},{"name":"Curation","description":"Bank and content management operations"},{"name":"Exchange APIs","description":"Signal exchange API configuration"},{"name":"Exchanges","description":"Signal exchange/collaboration management"},{"name":"Configuration","description":"System configuration endpoints"},{"name":"Development","description":"Development and testing endpoints"}],"x-integration-patterns":"# Integration Patterns for Strongly-Typed Languages\n\n## Dynamic Response Challenge\n\nThe HMA API returns dynamic objects where:\n- **Keys are algorithm names** (pdq, md5, sha256, etc.)\n- **Values are hash strings**\n- **Available algorithms depend on runtime configuration**\n\nThis creates challenges for strongly-typed languages that need known object shapes for:\n- Memory allocation at compile time\n- JSON deserialization to structs/classes\n- Type safety and compile-time validation\n\n## Required Workarounds\n\n### 1. Use Dynamic Data Structures\n```\nTypeScript: Record<string, string>\nGo:         map[string]string  \nSwift:      [String: String]\nRust:       HashMap<String, String>\nJava:       Map<String, String>\nC#:         Dictionary<string, string>\n```\n\n### 2. Runtime Algorithm Discovery\n```typescript\n// Discover available algorithms at runtime\nconst hashResponse = await hashContent(file);\nconst availableAlgorithms = Object.keys(hashResponse);\nconsole.log('Available:', availableAlgorithms); // [\"pdq\", \"md5\", \"sha256\"]\n```\n\n### 3. Algorithm Selection Strategy\n```typescript\n// Strategy 1: Use preferred algorithm if available\nfunction selectAlgorithm(hashResponse: Record<string, string>, preferred: string): string {\n  const available = Object.keys(hashResponse);\n  return available.includes(preferred) ? preferred : available[0];\n}\n\n// Strategy 2: Use algorithm priority list\nfunction selectBestAlgorithm(hashResponse: Record<string, string>): string {\n  const priority = ['pdq', 'sha256', 'md5']; // Most to least preferred\n  const available = Object.keys(hashResponse);\n  return priority.find(alg => available.includes(alg)) || available[0];\n}\n```\n\n### 4. Type-Safe Extraction\n```typescript\ninterface MatchingInput {\n  signal: string;\n  signal_type: string;\n}\n\nfunction extractMatchingInput(\n  hashResponse: Record<string, string>, \n  algorithm?: string\n): MatchingInput | null {\n  const selected = algorithm || Object.keys(hashResponse)[0];\n  \n  if (!(selected in hashResponse)) {\n    return null; // Algorithm not available\n  }\n  \n  return {\n    signal: hashResponse[selected],\n    signal_type: selected\n  };\n}\n```\n\n## Memory Allocation Strategies\n\n### Compile-Time Limitations\n- Cannot pre-allocate struct memory for unknown fields\n- Field names not known until API response received  \n- Memory layout unpredictable\n\n### Runtime Solutions\n- Use hash maps/dictionaries for dynamic key-value storage\n- Allocate memory during JSON parsing\n- Accept heap allocation overhead vs stack allocation\n\n### Performance Considerations\n```\nHash Map Lookup:     O(1) average, O(n) worst case\nDirect Field Access: O(1) guaranteed\nMemory Overhead:     Hash map > struct/class\n```\n\n## Error Handling Patterns\n\n### Graceful Algorithm Fallback\n```typescript\nasync function robustHashAndMatch(file: File) {\n  try {\n    const hashResponse = await hashContent(file);\n    const algorithms = Object.keys(hashResponse);\n    \n    if (algorithms.length === 0) {\n      throw new Error('No hashing algorithms available');\n    }\n    \n    // Try preferred algorithms in order\n    const preferred = ['pdq', 'sha256', 'md5'];\n    const algorithm = preferred.find(alg => algorithms.includes(alg)) || algorithms[0];\n    \n    const matchingInput = {\n      signal: hashResponse[algorithm],\n      signal_type: algorithm\n    };\n    \n    return await findMatches(matchingInput);\n  } catch (error) {\n    console.error('Hash and match failed:', error);\n    throw error;\n  }\n}\n```\n\n### Response Validation\n```typescript\nimport { z } from 'zod';\n\n// Validate dynamic hash response structure\nconst HashResponseSchema = z.record(z.string().min(1));\n\nfunction validateHashResponse(data: unknown): Record<string, string> {\n  try {\n    return HashResponseSchema.parse(data);\n  } catch (error) {\n    throw new Error(`Invalid hash response structure: ${error.message}`);\n  }\n}\n```\n\n## SDK Generation Considerations\n\n### Code Generator Limitations\nMost OpenAPI code generators struggle with:\n- `additionalProperties` schemas\n- Dynamic object shapes  \n- Runtime type determination\n\n### Generated Code Patterns\n```typescript\n// Typical generated interface (limited usefulness)\ninterface HashResponse {\n  [key: string]: string;\n}\n\n// Better custom wrapper\nclass HashResponseWrapper {\n  constructor(private data: Record<string, string>) {}\n  \n  getAvailableAlgorithms(): string[] {\n    return Object.keys(this.data);\n  }\n  \n  getHash(algorithm: string): string | undefined {\n    return this.data[algorithm];\n  }\n  \n  hasAlgorithm(algorithm: string): boolean {\n    return algorithm in this.data;\n  }\n  \n  toMatchingInput(algorithm?: string): MatchingInput {\n    const selected = algorithm || this.getAvailableAlgorithms()[0];\n    if (!this.hasAlgorithm(selected)) {\n      throw new Error(`Algorithm ${selected} not available`);\n    }\n    \n    return {\n      signal: this.data[selected],\n      signal_type: selected\n    };\n  }\n}\n```\n","security":[]}