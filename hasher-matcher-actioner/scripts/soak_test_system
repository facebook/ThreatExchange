#! /usr/bin/env python3
# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved

"""
Soak/endurance test a deployed instance of HMA

Besides deploying what is needed:
- A Cognito User that has access to the deloyed system
- Local AWS certs (if you were able to run tf apply you should be fine)  
- A place to set off the test (ec2 instance + long running tmux session)

Structure of the soak test

Initial set up (no point in a long running test if this doesn't work)
- Access to API via refresh token (+ client_id) 
- Image used has a hash that will match the systems index
- PR Configs (and associated signals) exist so match records will be created
- Action Rules (and associated actions) exist so action will send post request

Run
- Submit Content Test (done every interval=seconds)
- Sleep
- Refresh Token
- Repeat

ToDo Missing more involed checks (between submit and webhook):
  - The content record was created (with the expected metadata/additional fields) 
  - Brief wait: hash was created of that image and it matches the expected
  - wait: match record was created (if expected) and maps to correct signal values
  - longer wait: action record was created and maps to correct action label


```
python3 scripts/soak_test_system --api_url "https://abcd1234.execute-api.us-east-1.amazonaws.com/" --submission_batch_size 5 --second_between_batches 5
```

"""

import os
import argparse
import time
import threading
import uuid
import datetime

from submit_content_test import DeployedInstanceTestHelper
from listener import Listener

# Defaults (often it is easier to edit the script than provide the args)
API_URL = ""
REFRESH_TOKEN = ""
CLIENT_ID = ""

EXTERNAL_HOSTNAME = ""

ID_SEPARATOR = "-"


class SubmittingThread(threading.Thread):
    def __init__(
        self,
        helper: DeployedInstanceTestHelper,
        submission_batch_size=10,
        seconds_between_batches=10,
        **kwargs,
    ):
        super(SubmittingThread, self).__init__(**kwargs)
        self.daemon = True
        self._stop_signal = threading.Event()
        self.submission_batch_size = submission_batch_size
        self.seconds_between_batches = seconds_between_batches
        self.helper = helper

    def stop(self):
        self._stop_signal.set()

    def stopped(self):
        return self._stop_signal.is_set()

    def run(self):
        total_submitted = 0
        while True:
            if self.stopped():
                print(f"Submissions stopped. TOTAL SUBMITTED: {total_submitted}")
                return
            batch_prefix = f"soak_test{ID_SEPARATOR}{datetime.date.today().isoformat()}{ID_SEPARATOR}{str(uuid.uuid4())}"
            for i in range(self.submission_batch_size):
                content_id = f"{batch_prefix}-{i}"
                self.helper.submit_test_content(content_id)
                total_submitted += 1
            print(f"Submitter: total submission count {total_submitted}")
            time.sleep(self.seconds_between_batches)
            self.helper.refresh_api_token()


class ListeningThread(threading.Thread):
    def __init__(
        self,
        hostname,
        port,
        seconds_between_checks=5,
        **kwargs,
    ):
        super(ListeningThread, self).__init__(**kwargs)
        self.daemon = True
        self._stop_signal = threading.Event()
        self.seconds_between_checks = seconds_between_checks
        self.listener = Listener(hostname, port)

    def stop(self):
        self._stop_signal.set()

    def stopped(self):
        return self._stop_signal.is_set()

    def run(self):
        self.listener.start_listening()
        time.sleep(5)
        prev = 0
        while True:
            if self.stopped():
                self.listener.stop_listening()
                print(f"Listener stopped. TOTAL RECEIVED: ~{prev}")
                return
            request_count = self.listener.get_post_request_count()
            if prev != request_count:
                print(f"Listener: total POST requests received {request_count}")
                prev = request_count
            time.sleep(self.seconds_between_checks)


def start_soak(
    api_url: str,
    refresh_token: str,
    client_id: str,
    hostname: str,
    port: int,
    submission_batch_size: int,
    seconds_between_batches: int,
):
    helper = DeployedInstanceTestHelper(api_url, "", client_id, refresh_token)
    helper.refresh_api_token()
    helper.set_up_test(f"http://{hostname}:{port}")

    submitting_thread = SubmittingThread(
        helper, submission_batch_size, seconds_between_batches
    )
    listening_thread = ListeningThread(hostname, port)

    print(
        f"Beginning Soak Test: enter 'q' to stop submissions and again to stop listening."
    )
    listening_thread.start()
    time.sleep(3)
    submitting_thread.start()

    cmd = ""
    try:
        while cmd != "q":
            cmd = input("Enter 'q' to stop submitter: ")
    except KeyboardInterrupt:
        pass

    submitting_thread.stop()
    print("Submissions stopping")
    cmd = ""
    try:
        while cmd != "q":
            cmd = input("Enter 'q' to stop listener: ")
    except KeyboardInterrupt:
        pass

    listening_thread.stop()

    submitting_thread.join()
    listening_thread.join()

    helper.clean_up_test()
    print(f"Soak Test Stopped")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Start a soak test on a deployed HMA instance and submit until cancelled"
    )
    parser.add_argument(
        "--api_url",
        help="HMA's API URL",
        default=os.environ.get(
            "HMA_API_URL",
            API_URL,
        ),
    )
    parser.add_argument(
        "--refresh_token",
        help="refresh token to be used throughout a long running test",
        default=os.environ.get(
            "HMA_REFRESH_TOKEN",
            REFRESH_TOKEN,
        ),
    )
    parser.add_argument(
        "--client_id",
        help="id of app client for the pool",
        default=os.environ.get(
            "HMA_COGNITO_USER_POOL_CLIENT_ID",
            CLIENT_ID,
        ),
    )
    parser.add_argument(
        "--hostname",
        help="external hostname used to listen for the actioner",
        default=os.environ.get(
            "EXTERNAL_HOSTNAME",
            EXTERNAL_HOSTNAME,
        ),
    )
    parser.add_argument(
        "--port",
        help="port used to listen for the actioner",
        default=8080,
    )
    parser.add_argument(
        "--submission_batch_size",
        help="How many images to submit in each batch",
        default=10,
    )
    parser.add_argument(
        "--seconds_between_batches",
        help="number of seconds between completed submission batches",
        default=10,
    )

    args = parser.parse_args()

    start_soak(
        args.api_url,
        args.refresh_token,
        args.client_id,
        args.hostname,
        int(args.port),
        int(args.submission_batch_size),
        int(args.seconds_between_batches),
    )
